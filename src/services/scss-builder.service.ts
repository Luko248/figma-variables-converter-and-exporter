/**
 * SCSS file builder service
 */

import { CSSVariable, ScssFileOutput, ThemeScssOutput } from "../types/index";
import { toKebabCase } from "../helpers/string.helper";

/**
 * Groups variables by semantic sections for better organization
 */
function groupVariablesBySemantic(
  variables: Array<{ name: string; value: string }>
): Record<string, Array<{ name: string; value: string }>> {
  const sections: Record<string, Array<{ name: string; value: string }>> = {
    default: [],
  };

  variables.forEach((variable) => {
    // Extract semantic section from variable name
    const match = variable.name.match(/--\w+([A-Z][a-z]+)/);
    const section = match ? match[1].toLowerCase() : "default";

    if (!sections[section]) {
      sections[section] = [];
    }
    sections[section].push(variable);
  });

  return sections;
}

/**
 * Builds file content for a specific category
 */
const buildFileContent = (
  category: string,
  variables: Array<{ name: string; value: string }>
) => {
  console.log(`üî® Building ${category} file with ${variables.length} variables`);
  if (variables.length > 0) {
    console.log(
      `   First 3 variables:`,
      variables.slice(0, 3).map((v) => `${v.name}: ${v.value}`)
    );
  }

  const categoryUpper = category.toUpperCase();
  const exportDate = new Date().toLocaleString("en-US", {
    month: "numeric",
    day: "numeric",
    year: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric",
    hour12: true,
  });

  // Mixin names are always plural: colors, measures, fonts, shadows, gradients
  const mixinName =
    category === "color"
      ? "colors"
      : category === "gradient"
      ? "gradients"
      : category === "shadow"
      ? "shadows"
      : category;

  let content = `/*\n* ${categoryUpper} TOKENS GENERATED BY FIGMA EXPORTER\n*---------------------------------------------\n*\n* Exported at: ${exportDate}\n* File: ${category}.scss\n* Type: ${categoryUpper}\n*/\n\n@mixin create-${mixinName} {\n`;

  if (variables.length > 0) {
    // Group variables by semantic sections if needed
    const sections = groupVariablesBySemantic(variables);

    Object.entries(sections).forEach(([sectionName, sectionVars]) => {
      if (sectionName !== "default") {
        content += `\n/* --- ${sectionName} --- */\n`;
      }
      sectionVars.forEach((variable) => {
        content += `  ${variable.name}: ${variable.value};\n`;
      });
    });
  }

  content += "}\n";
  return content;
};

/**
 * Builds multi-file SCSS output with mixins
 */
export function buildSupernovaOutput(
  cssVariables: CSSVariable[]
): ScssFileOutput {
  console.log("üì¶ buildSupernovaOutput called with:", {
    isArray: Array.isArray(cssVariables),
    isUndefined: cssVariables === undefined,
    length: cssVariables?.length,
  });

  if (!cssVariables || !Array.isArray(cssVariables) || cssVariables.length === 0) {
    console.warn("‚ö†Ô∏è No variables provided to buildSupernovaOutput");
    return {
      colors: "/* No color variables found */",
      measures: "/* No measure variables found */",
      fonts: "/* No font variables found */",
      shadows: "/* No shadow variables found */",
      gradients: "/* No gradient variables found */",
      index: "",
      root: "",
    };
  }

  // Group variables by type
  const groupedVariables: Record<
    string,
    Array<{ name: string; value: string }>
  > = {};

  cssVariables.forEach((variable) => {
    if (!groupedVariables[variable.type]) {
      groupedVariables[variable.type] = [];
    }
    groupedVariables[variable.type].push({
      name: variable.name,
      value: variable.value,
    });
  });

  console.log(
    "üìä Grouped variables by type:",
    Object.keys(groupedVariables).map(
      (key) => `${key}: ${groupedVariables[key].length}`
    )
  );

  const colors = buildFileContent("color", groupedVariables.color || []);
  const measures = buildFileContent("measures", groupedVariables.measures || []);
  const fonts = buildFileContent("fonts", groupedVariables.fonts || []);
  const shadows = buildFileContent("shadow", groupedVariables.shadow || []);
  const gradients = buildFileContent("gradient", groupedVariables.gradient || []);
  const index =
    '@forward "colors";\n@forward "fonts";\n@forward "gradients";\n@forward "measures";\n@forward "shadows";\n\n';
  const root =
    '@use "_index" as *;\n\n@mixin create-root {\n  @include create-colors;\n  @include create-fonts;\n  @include create-gradients;\n  @include create-measures;\n  @include create-shadows;\n}\n\n';

  console.log("üìÑ Generated file sizes:", {
    colors: colors.length,
    measures: measures.length,
    fonts: fonts.length,
    shadows: shadows.length,
    gradients: gradients.length,
    index: index.length,
    root: root.length,
  });

  return {
    colors,
    measures,
    fonts,
    shadows,
    gradients,
    index,
    root,
  };
}

/**
 * Builds theme-aware multi-file SCSS output with mixins
 */
export function buildThemeAwareOutput(
  variablesByTheme: Record<string, CSSVariable[]>
): ThemeScssOutput {
  console.log("üé® Building theme-aware output...");
  const themes = Object.keys(variablesByTheme);
  console.log(`   Found ${themes.length} theme(s):`, themes);

  const result: ThemeScssOutput = {};

  themes.forEach((theme) => {
    // Convert theme name to kebab-case (lowercase with dashes)
    let themeName = themes.length === 1 ? "theme" : toKebabCase(theme);
    
    // Remove "light" suffix - only use suffix for dark themes
    // e.g., "Koop Light" ‚Üí "koop", "Koop Dark" ‚Üí "koop-dark"
    if (themeName.endsWith("-light")) {
      themeName = themeName.replace(/-light$/, "");
    }
    
    console.log(`   Processing theme: ${theme} ‚Üí ${themeName}`);
    console.log(`   Variables count: ${variablesByTheme[theme]?.length || 0}`);

    const output = buildSupernovaOutput(variablesByTheme[theme]);
    console.log(
      `   Generated files:`,
      Object.keys(output).map(
        (key) => `${key}(${output[key as keyof typeof output].length} chars)`
      )
    );

    result[themeName] = output;
  });

  console.log(`‚úÖ Theme-aware output complete. Themes:`, Object.keys(result));
  return result;
}

/**
 * Legacy function for backward compatibility
 * @deprecated Use buildSupernovaOutput instead
 */
export function buildCSSOutput(cssVariables: CSSVariable[]): string {
  const supernovaOutput = buildSupernovaOutput(cssVariables);
  return (
    supernovaOutput.colors +
    "\n" +
    supernovaOutput.measures +
    "\n" +
    supernovaOutput.fonts +
    "\n" +
    supernovaOutput.shadows +
    "\n" +
    supernovaOutput.gradients
  );
}
